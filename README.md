Задание №2.
Разработать алгоритм управления полетом беспилотных летательных аппаратов.

### Шаг 1: Анализ факторов, влияющих на управление полетом дрона

1. **Аэродинамические характеристики:** 
   - Подъемная сила и сопротивление воздуха.
   - Коэффициенты аэродинамических сил и моментов.
   - Воздействие ветра и погодных условий.

2. **Масса и распределение массы:** 
   - Общая масса дрона.
   - Распределение самой массы и центры масс.
   - Влияние груза и его расположение.

3. **Параметры двигателей:**
   - Мощность и тяга двигателей.
   - Характеристики работы при различных режимах.
   - Скорость отклика и максимальное ускорение.

4. **Электроника и датчики:** 
   - Гироскопы и акселерометры.
   - GPS и инерционные измерительные системы (ИМС).
   - Барометры, магнитометры.

5. **Управляющие сигналы и алгоритмы:** 
   - ПИД-регуляторы.
   - Управляющие правила и логика.
   - Влияние задержек и шума в сигналах.

### Шаг 2: Определение целей управления полетом

1. **Устойчивость:** 
   - Поддержание стабильного полета в любых условиях.
   - Уклонение от падения и переворота.

2. **Точность навигации:** 
   - Умение следовать заданной траектории.
   - Минимизация отклонений от маршрута.

3. **Энергоэффективность:** 
   - Продление времени полета путем оптимизации использования энергии.
   - Эффективное управление энергопотреблением двигателей и электроники.

4. **Безопасность:** 
   - Избегание столкновений.
   - Надежность системы в условиях отказов датчиков или двигателей.

5. **Адаптивность:** 
   - Способность адаптироваться к изменяющимся условиям, таким как ветер или изменение нагрузки.

### Шаг 3: Разработка алгоритма управления

1. **ПИД-регуляторы для стабилизации:**
   - Использование ПИД-регуляторов для управления по осям X, Y, Z и по углам наклона, рысканья и крена.
   - Построение отдельных ПИД-регуляторов для каждого параметра.

2. **Фильтры для обработки данных:**
   - Калмановский фильтр для улучшения точности данных от датчиков.
   - Низкочастотные фильтры для минимизации шума.

3. **Системы автоматической коррекции:**
   - Адаптивные алгоритмы для учета изменений в нагрузке или погодных условиях.
   - Использование моделей прогнозирования для корректировки траектории полета.

### Шаг 4: Описание основных шагов алгоритма

1. **Сбор данных:**
   - Входные данные: данные от гироскопов, акселерометров, GPS, ИМС, барометров и магнитометров.
   - Выходные данные: управляющие сигналы для двигателей.

2. **Предобработка данных:**
   - Применение фильтров к данным от датчиков для уменьшения шума и повышения точности.

3. **Вычисление ошибок:**
   - Определение отклонений от заданных параметров (высота, угол наклона и т.д.).

4. **Применение ПИД-регуляторов:**
   - Вычисление корректирующих воздействий для стабилизации и управления.

5. **Генерация управляющих сигналов:**
   - Формирование сигналов для двигателей на основе вычисленных корректировок.

### Шаг 5: Обоснование выбора элементов алгоритма

- **ПИД-регуляторы:** обеспечивают быстрое и точное управление, легко настраиваемы для различных условий полета.
- **Фильтры Калмана:** уменьшают влияние шума и ошибок измерений.
- **Адаптивные алгоритмы:** позволяют эффективно справляться с меняющимися условиями и требованиями к управлению, что способствует устойчивости и энергоэффективности.

### Шаг 6: Сценарии применения алгоритма

1. **Полет в безветренных условиях:** алгоритм обеспечивает стабильный полет и точное выполнение заданной траектории.
2. **Полет при сильном ветре:** адаптивные алгоритмы корректируют управление для компенсации изменений направления и скорости ветра.
3. **Полет с изменением нагрузки:** система автоматически подстраивается под изменение распределения массы или веса, поддерживая стабильность.
4. **Избегание препятствий:** алгоритм может использовать данные от дополнительных датчиков (лидары, камеры) для безопасного обхода препятствий.

### Шаг 7: Возможные улучшения алгоритма

- **Введение более сложных моделей машинного обучения:** для улучшения адаптивности и предсказания условий полета.
- **Оптимизация энергопотребления:** разработка более сложной системы предсказания и управление питанием двигателей.
- **Интеграция с внешними системами управления:** использование сетевых протоколов для координации действий группы дронов.

### Шаг 8: Выводы

Разработанный алгоритм управления полетом беспилотного летательного аппарата соответствует поставленным целям устойчивости, точности навигации, энергоэффективности и безопасности. Применение ПИД-регуляторов, фильтров Калмана и адаптивных алгоритмов позволяет обеспечить надежное управление в различных условиях. Возможные улучшения могут повысить адаптивность и оптимизацию энергопотребления. Общая эффективность алгоритма подтверждается его способностью поддерживать стабильность и точность полета, а также адаптироваться к изменяющимся условиям.

import time
import numpy as np
import math

class PID:
    def __init__(self, kP, kI, kD, setpoint=0.0):
        self.kP = kP
        self.kI = kI
        self.kD = kD
        self.setpoint = setpoint
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, measurement, dt):
        error = self.setpoint - measurement
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt
        self.prev_error = error

        output = self.kP * error + self.kI * self.integral + self.kD * derivative
        return output

class Drone:
    def __init__(self):
        self.position = np.array([0.0, 0.0, 0.0])  # X, Y, Z
        self.velocity = np.array([0.0, 0.0, 0.0])
        self.orientation = np.array([0.0, 0.0, 0.0])  # Roll, Pitch, Yaw

        # PID controllers for orientation
        self.roll_pid = PID(1.0, 0.1, 0.05)
        self.pitch_pid = PID(1.0, 0.1, 0.05)
        self.yaw_pid = PID(1.0, 0.1, 0.05)

        # PID controllers for position
        self.x_pid = PID(1.0, 0.1, 0.05)
        self.y_pid = PID(1.0, 0.1, 0.05)
        self.z_pid = PID(1.0, 0.1, 0.05)

    def update_orientation(self, roll, pitch, yaw):
        self.orientation = np.array([roll, pitch, yaw])

    def update_position(self, x, y, z):
        self.position = np.array([x, y, z])

    def get_sensor_data(self):
        # Симуляция данных с датчиков
        roll = self.orientation[0] + np.random.normal(0, 0.01)
        pitch = self.orientation[1] + np.random.normal(0, 0.01)
        yaw = self.orientation[2] + np.random.normal(0, 0.01)
        x = self.position[0] + np.random.normal(0, 0.01)
        y = self.position[1] + np.random.normal(0, 0.01)
        z = self.position[2] + np.random.normal(0, 0.01)
        return roll, pitch, yaw, x, y, z

    def update_control(self, dt):
        roll, pitch, yaw, x, y, z = self.get_sensor_data()

        roll_output = self.roll_pid.update(roll, dt)
        pitch_output = self.pitch_pid.update(pitch, dt)
        yaw_output = self.yaw_pid.update(yaw, dt)

        x_output = self.x_pid.update(x, dt)
        y_output = self.y_pid.update(y, dt)
        z_output = self.z_pid.update(z, dt)

        # Аппликация управляющих сигналов
        self.apply_control(roll_output, pitch_output, yaw_output, x_output, y_output, z_output)

    def apply_control(self, roll_output, pitch_output, yaw_output, x_output, y_output, z_output):
        # Здесь добавим базовую модель применения контролов к двигателям дрона
        # Вы вводите свои алгоритмы для управления моторами, клавишами или иными актуаторами
        print(f'Controlling with Roll: {roll_output}, Pitch: {pitch_output}, Yaw: {yaw_output}, X: {x_output}, Y: {y_output}, Z: {z_output}')

    def run(self):
        last_time = time.time()
        while True:
            current_time = time.time()
            dt = current_time - last_time
            last_time = current_time

            self.update_control(dt)
            time.sleep(0.01)

if __name__ == "__main__":
    drone = Drone()
    try:
        drone.run()
    except KeyboardInterrupt:
        print("Drone flight simulation stopped.")

Разъяснение кода:
Класс PID: Реализует ПИД-регулятор, который принимает коэффициенты и точку установки (setpoint), а также методы обновления состояния в зависимости от измерений.
Класс Drone: Содержит параметры полета дрона (позиция, ориентация) и PID-контроллеры для управления положением и ориентацией.
Методы update_orientation и update_position: Обновляют значения ориентации и позиции дрона.
Метод get_sensor_data: Симулирует получение данных с датчиков с некоторым шумом, что имитирует реальное поведение датчиков.
Метод update_control: Обновляет управляющие сигналы для ПИД-регуляторов и вызывает метод apply_control для применения управляющих воздействий.
Метод apply_control: Символически применяет управляющие сигналы (в реальных условиях здесь бы была логика управления моторами).
Метод run: Основной цикл, который обновляет состояние дрона и применяет управляющие сигналы.
Этот код представляет собой упрощенную симуляцию управления дроном с использованием ПИД-регуляторов и может стать основой для более сложных систем управления полетом.
